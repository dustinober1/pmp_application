generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String            @id @default(uuid())
  email             String            @unique
  passwordHash      String
  firstName         String
  lastName          String
  role              String            @default("USER")
  emailVerified     Boolean           @default(false)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  flashCardReviews  FlashCardReview[]
  createdFlashCards FlashCard[]       @relation("FlashCardCreatedBy")
  createdQuestions  Question[]        @relation("CreatedBy")
  refreshTokens        RefreshToken[]
  passwordResetTokens  PasswordResetToken[]

  progress     UserProgress[]
  testSessions UserTestSession[]
  studyStreak  StudyStreak?
  dailyGoal    DailyGoal?

  // Adaptive Learning Engine relations
  learningProfile           LearningProfile?
  examSessions              ExamSession[]
  studyPlans                StudyPlan[]
  annotations               Annotation[]
  bookmarks                 Bookmark[]
  discussionComments        DiscussionComment[]
  commentVotes              CommentVote[]
  commentReports            CommentReport[]
  certification             UserCertification?
  notifications             Notification[]
  notificationSubscriptions NotificationSubscription[]
  notificationPreference    NotificationPreference?

  @@index([email])
  @@map("users")
}

model Domain {
  id               String          @id @default(uuid())
  name             String          @unique
  description      String
  weightPercentage Float
  color            String
  flashCards       FlashCard[]
  questions        Question[]
  progress         UserProgress[]
  domainMasteries  DomainMastery[]
  // Tests that focus on this domain
  tests            TestDomain[]

  @@map("domains")
}

model Question {
  id                 String               @id @default(uuid())
  domainId           String
  questionText       String
  scenario           String?
  choices            String
  correctAnswerIndex Int                  @default(0)
  explanation        String
  difficulty         String               @default("MEDIUM")
  methodology        String               @default("HYBRID")
  isActive           Boolean              @default(true)
  createdBy          String
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  creator            User                 @relation("CreatedBy", fields: [createdBy], references: [id])
  domain             Domain               @relation(fields: [domainId], references: [id], onDelete: Cascade)
  testQuestions      TestQuestion[]
  answers            UserAnswer[]
  sessionQuestions   SessionQuestion[]
  examAnswers        ExamAnswer[]
  annotations        Annotation[]
  bookmarks          Bookmark[]
  discussionComments DiscussionComment[]
  explanation_deep   QuestionExplanation?

  @@index([domainId])
  @@index([createdBy])
  @@map("questions")
}

model FlashCard {
  id         String            @id @default(uuid())
  domainId   String
  frontText  String
  backText   String
  category   String
  difficulty String            @default("MEDIUM")
  isActive   Boolean           @default(true)
  createdBy  String
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  reviews    FlashCardReview[]
  creator    User              @relation("FlashCardCreatedBy", fields: [createdBy], references: [id])
  domain     Domain            @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@index([domainId])
  @@index([createdBy])
  @@index([isActive, domainId]) // Composite for filtered domain queries
  @@index([isActive, difficulty]) // Composite for difficulty filtering
  @@map("flashcards")
}

model PracticeTest {
  id               String            @id @default(uuid())
  name             String
  description      String
  totalQuestions   Int               @default(185)
  timeLimitMinutes Int               @default(230)
  isActive         Boolean           @default(true)
  createdAt        DateTime          @default(now())
  testQuestions    TestQuestion[]
  sessions         UserTestSession[]
  // Domain filtering: links test to specific domain(s) it covers
  // If empty, test includes questions from all domains (full-spectrum test)
  domains          TestDomain[]

  @@map("practice_tests")
}

model TestQuestion {
  id         String       @id @default(uuid())
  testId     String
  questionId String
  orderIndex Int
  question   Question     @relation(fields: [questionId], references: [id], onDelete: Cascade)
  test       PracticeTest @relation(fields: [testId], references: [id], onDelete: Cascade)

  @@unique([testId, questionId])
  @@index([testId])
  @@index([questionId])
  @@map("test_questions")
}

// Junction table for domain-specific test filtering
// Allows tests to be associated with specific domain(s)
// Tests without any TestDomain entries are full-spectrum tests (all domains)
model TestDomain {
  id       String       @id @default(uuid())
  testId   String
  domainId String
  test     PracticeTest @relation(fields: [testId], references: [id], onDelete: Cascade)
  domain   Domain       @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@unique([testId, domainId])
  @@index([testId])
  @@index([domainId])
  @@map("test_domains")
}

model UserTestSession {
  id               String            @id @default(uuid())
  userId           String
  testId           String
  startedAt        DateTime          @default(now())
  completedAt      DateTime?
  timeLimitMinutes Int
  status           String            @default("IN_PROGRESS")
  score            Int?
  totalQuestions   Int
  correctAnswers   Int?
  answers          UserAnswer[]
  sessionQuestions SessionQuestion[]
  test             PracticeTest      @relation(fields: [testId], references: [id], onDelete: Cascade)
  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([testId])
  @@index([userId, status]) // Composite for user's active/completed sessions
  @@map("user_test_sessions")
}

model SessionQuestion {
  id         String          @id @default(uuid())
  sessionId  String
  questionId String
  orderIndex Int
  session    UserTestSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  question   Question        @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, questionId])
  @@index([sessionId])
  @@index([questionId])
  @@index([sessionId, orderIndex])
  @@map("session_questions")
}

model UserAnswer {
  id                  String          @id @default(uuid())
  sessionId           String
  questionId          String
  selectedAnswerIndex Int
  isCorrect           Boolean
  isFlagged           Boolean         @default(false)
  answeredAt          DateTime        @default(now())
  timeSpentSeconds    Int
  question            Question        @relation(fields: [questionId], references: [id], onDelete: Cascade)
  session             UserTestSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, questionId])
  @@index([sessionId])
  @@index([questionId])
  @@map("user_answers")
}

model UserProgress {
  id                     String   @id @default(uuid())
  userId                 String
  domainId               String
  questionsAnswered      Int      @default(0)
  correctAnswers         Int      @default(0)
  averageTimePerQuestion Float    @default(0)
  lastActivityAt         DateTime @default(now())
  domain                 Domain   @relation(fields: [domainId], references: [id], onDelete: Cascade)
  user                   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, domainId])
  @@index([userId])
  @@index([domainId])
  @@map("user_progress")
}

model FlashCardReview {
  id           String    @id @default(uuid())
  userId       String
  flashCardId  String
  reviewedAt   DateTime  @default(now())
  difficulty   String    @default("GOOD") // AGAIN, HARD, GOOD, EASY
  easeFactor   Float     @default(2.5) // SM-2 ease factor (min 1.3)
  interval     Int       @default(1) // Days until next review
  lapses       Int       @default(0) // Number of times "Again" was pressed
  nextReviewAt DateTime
  reviewCount  Int       @default(1)
  flashCard    FlashCard @relation(fields: [flashCardId], references: [id], onDelete: Cascade)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, flashCardId])
  @@index([userId])
  @@index([flashCardId])
  @@index([nextReviewAt])
  @@index([userId, nextReviewAt]) // Composite for user's due cards
  @@map("flash_card_reviews")
}

model StudyStreak {
  id             String   @id @default(uuid())
  userId         String   @unique
  currentStreak  Int      @default(0)
  longestStreak  Int      @default(0)
  lastStudyDate  DateTime @default(now())
  totalStudyDays Int      @default(0)
  user           User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@map("study_streaks")
}

model DailyGoal {
  id                     String   @id @default(uuid())
  userId                 String   @unique
  flashcardGoal          Int      @default(20) // Cards to review per day
  questionsGoal          Int      @default(25) // Questions to answer per day
  cardsReviewedToday     Int      @default(0)
  questionsAnsweredToday Int      @default(0)
  lastResetDate          DateTime @default(now())
  user                   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("daily_goals")
}

model RefreshToken {
  id        String    @id @default(uuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  createdAt DateTime  @default(now())
  revokedAt DateTime?
  userAgent String?
  ipAddress String?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model PasswordResetToken {
  id          String    @id @default(uuid())
  userId      String
  tokenHash   String    @unique
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
  usedAt      DateTime?
  userAgent   String?
  ipAddress   String?
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

// Adaptive Learning Engine Models

model LearningProfile {
  id               String          @id @default(uuid())
  userId           String          @unique
  lastCalculatedAt DateTime        @default(now())
  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  domainMasteries  DomainMastery[]
  insights         Insight[]

  @@map("learning_profiles")
}

model DomainMastery {
  id               String          @id @default(uuid())
  profileId        String
  domainId         String
  score            Float           @default(50)
  trend            String          @default("stable")
  accuracyRate     Float           @default(0)
  consistencyScore Float           @default(0)
  difficultyScore  Float           @default(0)
  questionCount    Int             @default(0)
  lastActivityAt   DateTime        @default(now())
  peakScore        Float           @default(50)
  profile          LearningProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  domain           Domain          @relation(fields: [domainId], references: [id])

  @@unique([profileId, domainId])
  @@index([profileId])
  @@index([domainId])
  @@map("domain_masteries")
}

model Insight {
  id        String          @id @default(uuid())
  profileId String
  type      String
  title     String
  message   String
  priority  String          @default("medium")
  actionUrl String?
  isRead    Boolean         @default(false)
  createdAt DateTime        @default(now())
  profile   LearningProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId, createdAt])
  @@map("insights")
}

// Exam Simulator Models

model ExamSession {
  id               String       @id @default(uuid())
  userId           String
  startedAt        DateTime     @default(now())
  completedAt      DateTime?
  breakTakenAt     DateTime?
  status           String       @default("in_progress")
  score            Int?
  passed           Boolean?
  totalTimeSeconds Int?
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  answers          ExamAnswer[]

  @@index([userId, status])
  @@map("exam_sessions")
}

model ExamAnswer {
  id                  String      @id @default(uuid())
  sessionId           String
  questionId          String
  selectedAnswerIndex Int
  isCorrect           Boolean
  timeSpentSeconds    Int
  answeredAt          DateTime    @default(now())
  session             ExamSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  question            Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, questionId])
  @@index([sessionId])
  @@map("exam_answers")
}

// Study Plan Models

model StudyPlan {
  id             String      @id @default(uuid())
  userId         String
  targetExamDate DateTime
  hoursPerDay    Float
  status         String      @default("active")
  progressStatus String      @default("on_track")
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  tasks          StudyTask[]

  @@index([userId, status])
  @@map("study_plans")
}

model StudyTask {
  id               String    @id @default(uuid())
  planId           String
  date             DateTime
  type             String
  description      String
  estimatedMinutes Int
  domainFocus      String?
  isCompleted      Boolean   @default(false)
  completedAt      DateTime?
  plan             StudyPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@index([planId, date])
  @@map("study_tasks")
}

// Annotation Models

model Annotation {
  id         String   @id @default(uuid())
  userId     String
  questionId String
  content    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([userId])
  @@map("annotations")
}

model Bookmark {
  id         String   @id @default(uuid())
  userId     String
  questionId String
  category   String   @default("review_later")
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([userId, category])
  @@map("bookmarks")
}

// Discussion Models

model DiscussionComment {
  id               String              @id @default(uuid())
  questionId       String
  userId           String
  content          String
  parentId         String?
  upvotes          Int                 @default(0)
  isExpertVerified Boolean             @default(false)
  isHidden         Boolean             @default(false)
  reportCount      Int                 @default(0)
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  question         Question            @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user             User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent           DiscussionComment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies          DiscussionComment[] @relation("CommentReplies")
  votes            CommentVote[]
  reports          CommentReport[]

  @@index([questionId, createdAt])
  @@index([questionId, upvotes])
  @@map("discussion_comments")
}

model CommentVote {
  id        String            @id @default(uuid())
  commentId String
  userId    String
  createdAt DateTime          @default(now())
  comment   DiscussionComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@map("comment_votes")
}

model CommentReport {
  id        String            @id @default(uuid())
  commentId String
  userId    String
  reason    String
  createdAt DateTime          @default(now())
  comment   DiscussionComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@map("comment_reports")
}

// Question Enhancement

model QuestionExplanation {
  id             String   @id @default(uuid())
  questionId     String   @unique
  choiceIndex    Int
  explanation    String
  misconception  String?
  pmbokReference String?
  question       Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("question_explanations")
}

// User Enhancement

model UserCertification {
  id             String    @id @default(uuid())
  userId         String    @unique
  isPmpCertified Boolean   @default(false)
  verifiedAt     DateTime?
  certificateId  String?
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_certifications")
}

// Notification Models

model Notification {
  id        String    @id @default(uuid())
  userId    String
  type      String
  title     String
  body      String
  link      String?
  metadata  Json?
  isRead    Boolean   @default(false)
  readAt    DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, isRead, createdAt])
  @@map("notifications")
}

model NotificationSubscription {
  id        String   @id @default(uuid())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("notification_subscriptions")
}

model NotificationPreference {
  id             String   @id @default(uuid())
  userId         String   @unique
  pushEnabled    Boolean  @default(true)
  emailEnabled   Boolean  @default(false)
  emailFrequency String   @default("weekly")
  studyReminders Boolean  @default(true)
  achievements   Boolean  @default(true)
  digestEnabled  Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("notification_preferences")
}

// Audit Log Model

model AuditLog {
  id         String   @id @default(uuid())
  userId     String?
  userEmail  String?
  action     String
  entityType String
  entityId   String?
  oldValues  Json?
  newValues  Json?
  ipAddress  String?
  userAgent  String?
  metadata   Json?
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@map("audit_logs")
}
