/**
 * Mock Factories for Testing
 * Auto-generated by test-agent.ts
 */

import { User, Domain, Task, Flashcard, PracticeQuestion, Team } from '@pmp/shared';

/**
 * Generate mock user data
 */
export function mockUser(overrides: Partial<User> = {}): User {
  return {
    id: overrides.id || crypto.randomUUID(),
    email: overrides.email || 'test@example.com',
    name: overrides.name || 'Test User',
    emailVerified: overrides.emailVerified ?? true,
    failedLoginAttempts: overrides.failedLoginAttempts ?? 0,
    lockedUntil: overrides.lockedUntil || null,
    createdAt: overrides.createdAt || new Date(),
    updatedAt: overrides.updatedAt || new Date(),
    ...overrides,
  };
}

/**
 * Generate mock domain data
 */
/**
 * Generate mock domain data
 */
export function mockDomain(overrides: Partial<Domain> = {}): Domain {
  return {
    id: overrides.id || crypto.randomUUID(),
    name: overrides.name || 'People',
    code: overrides.code || 'PEOPLE',
    description: overrides.description || 'Test domain description',
    weightPercentage: overrides.weightPercentage || 42,
    orderIndex: overrides.orderIndex || 1,
    ...overrides,
  };
}

/**
 * Generate mock task data
 */
/**
 * Generate mock task data
 */
export function mockTask(overrides: Partial<Task> = {}): Task {
  return {
    id: overrides.id || crypto.randomUUID(),
    domainId: overrides.domainId || crypto.randomUUID(),
    code: overrides.code || '1.1',
    name: overrides.name || 'Test Task',
    description: overrides.description || 'Test task description',
    enablers: overrides.enablers || ['Enabler 1', 'Enabler 2'],
    orderIndex: overrides.orderIndex || 1,
    ...overrides,
  };
}

/**
 * Generate mock flashcard data
 */
export function mockFlashcard(overrides: Partial<Flashcard> = {}): Flashcard {
  return {
    id: overrides.id || crypto.randomUUID(),
    domainId: overrides.domainId || crypto.randomUUID(),
    taskId: overrides.taskId || crypto.randomUUID(),
    front: overrides.front || 'Test Front',
    back: overrides.back || 'Test Back',
    isCustom: overrides.isCustom ?? false,
    createdBy: overrides.createdBy,
    createdAt: overrides.createdAt || new Date(),
    ...overrides,
  };
}


/**
 * Generate mock practice question data
 */
export function mockPracticeQuestion(overrides: Partial<PracticeQuestion> = {}): PracticeQuestion {
  const questionId = overrides.id || crypto.randomUUID();
  return {
    id: questionId,
    domainId: overrides.domainId || crypto.randomUUID(),
    taskId: overrides.taskId || crypto.randomUUID(),
    questionText: overrides.questionText || 'Test question?',
    difficulty: overrides.difficulty || 'medium',
    explanation: overrides.explanation || 'Test explanation',
    correctOptionId: '1',
    relatedFormulaIds: overrides.relatedFormulaIds || [],
    options: overrides.options || [
      { id: '1', questionId, text: 'Option A', isCorrect: true },
      { id: '2', questionId, text: 'Option B', isCorrect: false },
      { id: '3', questionId, text: 'Option C', isCorrect: false },
      { id: '4', questionId, text: 'Option D', isCorrect: false },
    ],
    createdAt: overrides.createdAt || new Date(),
    ...overrides,
  };
}

/**
 * Generate mock team data
 */
export function mockTeam(overrides: Partial<Team> = {}): Team {
  return {
    id: overrides.id || crypto.randomUUID(),
    name: overrides.name || 'Test Team',
    adminId: overrides.adminId || crypto.randomUUID(),
    licenseCount: overrides.licenseCount || 10,
    members: overrides.members || [],
    createdAt: overrides.createdAt || new Date(),
    ...overrides,
  };
}

/**
 * Generate array of mock items
 */
export function mockArray<T>(
  factory: (overrides?: Partial<T>) => T,
  count: number,
  overrides?: Partial<T>
): T[] {
  return Array.from({ length: count }, () => factory(overrides));
}

/**
 * Generate mock Prisma response with pagination
 */
export function mockPaginatedResponse<T>(items: T[], page: number = 1, limit: number = 10) {
  const total = items.length;
  const totalPages = Math.ceil(total / limit);
  const startIndex = (page - 1) * limit;
  const endIndex = startIndex + limit;
  const paginatedItems = items.slice(startIndex, endIndex);

  return {
    items: paginatedItems,
    pagination: {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
    },
  };
}

/**
 * Mock JWT token payload
 */
export function mockJwtPayload(overrides: Partial<import('@pmp/shared').JwtPayload> = {}) {
  return {
    userId: overrides.userId || crypto.randomUUID(),
    email: overrides.email || 'test@example.com',
    tierId: overrides.tierId || 'free',
    ...overrides,
  };
}
