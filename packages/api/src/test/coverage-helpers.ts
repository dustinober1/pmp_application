/**
 * Coverage Helpers for Testing
 * Auto-generated by test-agent.ts
 */

import type { CoverageMap } from 'istanbul-lib-coverage';

interface CoverageSummary {
  lines: { total: number; covered: number; percentage: number };
  functions: { total: number; covered: number; percentage: number };
  branches: { total: number; covered: number; percentage: number };
  statements: { total: number; covered: number; percentage: number };
}

/**
 * Check if coverage meets threshold (80%)
 */
export function meetsThreshold(summary: CoverageSummary, threshold: number = 80): boolean {
  return (
    summary.lines.percentage >= threshold &&
    summary.functions.percentage >= threshold &&
    summary.branches.percentage >= threshold &&
    summary.statements.percentage >= threshold
  );
}

/**
 * Get uncovered line ranges
 */
export function getUncoveredLines(coverageMap: CoverageMap, filename: string): number[][] {
  const fileCoverage = coverageMap.data[filename];
  if (!fileCoverage) return [];

  const uncovered: number[][] = [];
  let currentRange: number[] | null = null;

  for (const line of Object.keys(fileCoverage.statementMap)) {
    const lineNum = parseInt(line, 10);
    const coverage = fileCoverage.s[lineNum];

    if (coverage === 0) {
      if (currentRange === null) {
        currentRange = [lineNum, lineNum];
      } else {
        currentRange[1] = lineNum;
      }
    } else {
      if (currentRange !== null) {
        uncovered.push(currentRange);
        currentRange = null;
      }
    }
  }

  if (currentRange !== null) {
    uncovered.push(currentRange);
  }

  return uncovered;
}

/**
 * Format coverage report for CLI output
 */
export function formatCoverageReport(summary: CoverageSummary): string {
  const formatMetric = (name: string, metric: { percentage: number }) => {
    const status = metric.percentage >= 80 ? '✓' : '✗';
    const bar =
      '█'.repeat(Math.floor(metric.percentage / 5)) +
      '░'.repeat(20 - Math.floor(metric.percentage / 5));
    return `${status} ${name.padEnd(12)} ${bar} ${metric.percentage.toFixed(1)}%`;
  };

  return `
Coverage Summary:
----------------
${formatMetric('Lines', summary.lines)}
${formatMetric('Functions', summary.functions)}
${formatMetric('Branches', summary.branches)}
${formatMetric('Statements', summary.statements)}
----------------
${meetsThreshold(summary) ? '✓ Coverage threshold met!' : '✗ Coverage below 80% threshold'}
`;
}

/**
 * Generate test suggestions based on uncovered lines
 */
export function suggestTestsForUncovered(coverageMap: CoverageMap, filename: string): string[] {
  const uncoveredLines = getUncoveredLines(coverageMap, filename);
  const suggestions: string[] = [];

  suggestions.push(`File: ${filename}`);
  suggestions.push('Uncovered line ranges:');

  for (const [start, end] of uncoveredLines) {
    const range = start === end ? `Line ${start}` : `Lines ${start}-${end}`;
    suggestions.push(`  - ${range}`);
    suggestions.push(`    Suggestion: Add test case for this code path`);
  }

  return suggestions;
}

/**
 * Calculate coverage delta between two runs
 */
export function calculateCoverageDelta(before: CoverageSummary, after: CoverageSummary): number {
  const beforeAvg =
    (before.lines.percentage +
      before.functions.percentage +
      before.branches.percentage +
      before.statements.percentage) /
    4;

  const afterAvg =
    (after.lines.percentage +
      after.functions.percentage +
      after.branches.percentage +
      after.statements.percentage) /
    4;

  return afterAvg - beforeAvg;
}
